
AVRASM ver. 2.1.42  C:\SVN\lc-meter-avr\LC.asm Sun Jan 08 17:21:22 2012

C:\SVN\lc-meter-avr\LC.asm(24): Including file 'C:\Program Files (x86)\Atmel\AVR Tools\AvrAssembler2\Appnotes\2313def.inc'
                 
                 
                 ;**
                 ;** Project......: L & C Meter, http://home.ict.nl/~fredkrom/
                 ;**
                 ;** Platform.....: AT90S2313 or ATtiny2313
                 ;**
                 ;** Licence......: This software is freely available for non-commercial 
                 ;**                use - i.e. for research and experimentation only!
                 ;**
                 ;** Programmer...: F.W. Krom, PE0FKO
                 ;** 
                 ;** Description..: Meet de L & C waarde, zelf calibrerend door bekende C.
                 ;**
                 ;** History......: 11/04/2005 V0.1 First complete working version.
                 ;**                12/04/2005 V0.2 Instellen reference C
                 ;**                15/04/2005 V0.3 Format 5 digits
                 ;**                22/12/2006 V0.4 Bugfix prescale & LCD
                 ;**                02/05/2007 V0.5 Ref-C in EEProm or ROM, Compile switch
                 ;**                17/02/2008 V0.6 If eeprom 0xFF the write _Cref
                 ;**
                 ;**************************************************************************/
                 .list
                 
                 ;.equ	xtal		= 8000000	; 8MHz
                 .equ	xtal		= 10000000	; 10MHz
                 
                 ; Bekende referentie C
                 .equ	_Cref		= 940	; 940pF
                 .equ	_UseEEProm	= 1	; Store/Load CRef from EEProm
                 
                 .equ	prescale	= 64	; timer0 prescaler count 64
                 ;.equ	prescale	= 256	; timer0 prescaler count 256
                 
                 ; N = uS * xtal / (prescale * 256) / 10e6 
                 .equ	ticks_40ms	= 40*xtal/prescale/256000
                 .equ	ticks_400ms	= 400*xtal/prescale/256000
                 
                 ; Maximale tijd die we meten voor pulsen.
                 ; Bij 10MHz en prescaler van 64 is dat minimaal 610 Hz (1,6384ms)
                 ; Bij 10MHz en prescaler van 256 is dat minimaal 152 Hz (6.554ms)
                 
                 ;.equ	portmax	= 0x7f		; 128 * 64 / 10MHz = 1.22 kHz
                 
                 ;            AT90S2313
                 ;            +--+-+--+
                 ;     !RESET |  |_|  | VCC
                 ;    (RX)PD0 |       | PB7(SCK)
                 ;    (TX)PD1 |       | PB6(MISO)
                 ;      XTAL2 |       | PB5(MOSI)
                 ;      XTAL1 |       | PB4
                 ;  (INT0)PD2 |       | PB3(OC1)
                 ;  (INT1)PD3 |       | PB2
                 ;    (T0)PD4 |       | PB1(AIN1)
                 ;    (T1)PD5 |       | PB0(AIN0)
                 ;        GND |       | PD6(ICP)
                 ;            +-------+
                 ;
                 ; PD0	X	Not in use
                 ; PD1	X	Not in use
                 ; PD2	O	Relay C/L switch
                 ; PD3	O	Relay ref C
                 ; PD4	X	Not in use
                 ; PD5	I	Frequence input
                 ; PD6	X	Not in use
                 ; PB0	I	Switch Calibrate
                 ; PB1	I	Switch Mode
                 ; PB2	O	LCD - RS
                 ; PB3	O	LCD - EN
                 ; PB4	O	LCD - D4
                 ; PB5	O	LCD - D5
                 ; PB6	O	LCD - D6
                 ; PB7	O	LCD - D7
                 
                 .macro	IO	; <name> <port> <pin>
                 .set	prt_@0		= PORT@1
                 .set	pin_@0		= PIN@1		; Input use PIN
                 .set	ddr_@0		= DDR@1
                 .set	bit_@0		= P@1@2
                 .endmacro
                 
                 IO	freq,D,5		; T1 Freq input 16 bit counter
                 IO	relay_refc,D,3		; Relay reference C
                 IO	relay_inp,D,2		; Relay L or C
                 IO	mode,B,1		; Switch L or C
                 IO	calibr,B,0		; Switch calibrate
                 IO	lcd,B,4			; LCD Data B4..B7
                 IO	rs,B,2			; LCD RS B2
                 IO	en,B,3			; LCD EN B3
                 
                 .macro	IOInp	; <name>
                 	cbi	ddr_@0,bit_@0
                 .endmacro
                 
                 .macro	IOOut	; <name>
                 	sbi	ddr_@0,bit_@0
                 .endmacro
                 
                 .macro	IOSet	; <name>
                 	sbi	prt_@0,bit_@0
                 .endmacro
                 
                 .macro	IOClear	; <name>
                 	cbi	prt_@0,bit_@0
                 .endmacro
                 
                 .macro	storeX	; <memory>
                 	ldi	ZL,byte1(@0)
                 	rcall	stX
                 .endmacro
                 
                 .macro	storeY	; <memory>
                 	ldi	ZL,byte1(@0)
                 	rcall	stY
                 .endmacro
                 
                 .macro	loadX	; <memory>
                 	ldi	ZL,byte1(@0)
                 	rcall	ldX
                 .endmacro
                 
                 .macro	loadY	; <memory>
                 	ldi	ZL,byte1(@0)
                 	rcall	ldY
                 .endmacro
                 
                 .macro	loadXi	; <value>
                 	ldi	RX0,byte1(@0)
                 	ldi	RX1,byte2(@0)
                 	ldi	RX2,byte3(@0)
                 	ldi	RX3,byte4(@0)
                 .endmacro
                 
                 
                 ;***** Registers
                 .undef	XL	; r26
                 .undef	XH	; r27
                 .undef	YL	; r28
                 .undef	YH	; r29
                 
                 .def	freqL	= r1
                 .def	freqH	= r2
                 
                 .def	RY0	= r4
                 .def	RY1	= r5
                 .def	RY2	= r6
                 .def	RY3	= r7
                 
                 .def	RR0	= r8
                 .def	RR1	= r9
                 .def	RR2	= r10
                 .def	RR3	= r11
                 .def	RR4	= r12
                 
                 .def	ssreg	= r28
                 .def	porttim	= r29
                 .def	portval	= r15
                 
                 .def	RX0	= r24;r16
                 .def	RX1	= r25;r17
                 .def	RX2	= r18
                 .def	RX3	= r19
                 .def	RX4	= r20
                 .def	RX5	= r21
                 .def	RX6	= r22
                 .def	RX7	= r14;r23
                 
                 .def	ticks	= r16;r24	; decrement every timer1 interrupt (8,192ms)
                 
                 .def	menu	= r17;r25
                 .def	chr	= r26		; output char
                 .def	tmp	= r27		; Scratchregister
                 
                 .def	status	= r23
                 
                 .undef	ZH
                 .def	zero	= r31		; ZH
                 
                 .equ	sMenuAll	= 1
                 .equ	sRecal		= 2
                 
                 ;--------------------------------------------------------------------
                 ;-- SRAM variablen
                 ;--------------------------------------------------------------------
                 .dseg
                 .equ	buflen	= 11			; Number buffer length
                 .equ	varlen	= 4
                 
000060           Cref:	.byte	varlen			; C Reference
000064           C:	.byte	varlen			; OSC Capaciteit
000068           L:	.byte	varlen			; OSC Inductie
00006c           N1:	.byte	varlen			; Count freq F1
000070           N2:	.byte	varlen			; Count freq F2
000074           NQ1:	.byte	varlen			; Count freq F1^2
000078           NQ2:	.byte	varlen			; Count freq F2^2
00007c           ND:	.byte	varlen			; Count freq F1^2 - F2^2
000080           BUFFER:	.byte	buflen			; Buffer number string
00008b           KM1:	.byte	varlen			; -1
00008f           K100:	.byte	varlen			; 100
000093           KL:	.byte	varlen			; Constant L calculation
000097           KFRQ:	.byte	varlen			; Constant frequence counter
                 
                 .if _UseEEProm
                 ;--------------------------------------------------------------------
                 ;-- Reference C value at EEPROM
                 ;--------------------------------------------------------------------
                 .eseg
000000 ac 03     	.dw	_Cref
                 .endif
                 ;--------------------------------------------------------------------
                 ;-- Interrupt table AT90S2313
                 ;--------------------------------------------------------------------
                 .cseg
                 .org 0
000000 c096      	rjmp	RESET			; Reset Handle
000001 9518      	reti				; IRQ0 Handler
000002 9518      	reti				; IRQ1 Handler
000003 9518      	reti				; Timer1 Capture Handler
000004 9518      	reti				; Timer1 Compare Handler
000005 c087      	rjmp	TIMER1			; Timer1 Overflow Handler
000006 c079      	rjmp	TIMER0			; Timer0 Overflow Handler
000007 9518      	reti				; UART RX Complete Handler
000008 9518      	reti				; UDR Empty Handler
000009 9518      	reti				; UART TX Complete Handler
00000a 9518      	reti				; Analog Comparator Handler
                 
                 ;--------------------------------------------------------------------
                 ;-- Text constants
                 ;--------------------------------------------------------------------
                 
00000b 434c
00000c 4d20
00000d 7465
00000e 7265
00000f 202c
000010 4550
000011 4630
000012 4f4b
000013 0000      tHead:	.db	"LC Meter, PE0FKO",0,0
000014 2020
000015 4320
000016 7061
000017 6361
000018 7469
000019 6e61
00001a 6563
00001b 2020
00001c 0000      tCap:	.db	"   Capacitance  ",0,0
00001d 2020
00001e 4920
00001f 646e
000020 6375
000021 6174
000022 636e
000023 2065
000024 2020
000025 0000      tIndc:	.db	"   Inductance   ",0,0
000026 2020
000027 4620
000028 6572
000029 7571
00002a 6e65
00002b 7963
00002c 4320
00002d 2020
00002e 0000      tFreqC:	.db	"   Frequency C  ",0,0
00002f 2020
000030 4620
000031 6572
000032 7571
000033 6e65
000034 7963
000035 4c20
000036 2020
000037 0000      tFreqL:	.db	"   Frequency L  ",0,0
000038 2d2d
000039 6143
00003a 696c
00003b 7262
00003c 7461
00003d 6e69
00003e 2d67
00003f 202d
000040 0000      tCali:	.db	"--Calibrating-- ",0,0
000041 2d2d
000042 6f4e
000043 6f20
000044 6373
000045 6c69
000046 7461
000047 726f
000048 2d2d
000049 0000      tNoOSC:	.db	"--No oscilator--",0,0
00004a 2020
00004b 5220
00004c 6665
00004d 7265
00004e 6e65
00004f 6563
000050 4320
000051 2020
000052 0000      tCref:	.db	"   Reference C  ",0,0
                 
000053 e46d
000054 e4e4
000055 6e6e
000056 706e
000057 7070      tCf:	.db	"m",0xE4,0xE4,0xE4,"nnn","ppp"
000058 6d20
000059 6d6d
00005a e4e4
00005b 6ee4
00005c 6e6e      tLf:	.db	" ","mmm",0xE4,0xE4,0xE4,"nnn"
00005d 4d47
00005e 4d4d
00005f 4b4b
000060 204b
000061 2020      tFf:	.db	"G","MMM","KKK   "
                 
000062 7843
000063 3d20
000064 0020      tCx:	.db	"Cx = ",0
000065 784c
000066 3d20
000067 0020      tLx:	.db	"Lx = ",0
000068 4320
000069 3d20
00006a 0020      tC:	.db	" C = ",0
00006b 4c20
00006c 3d20
00006d 0020      tL:	.db	" L = ",0
00006e 4620
00006f 3d20
000070 0020      tF:	.db	" F = ",0
                 
000071 2046
000072 0020      tCe:	.db	"F  ",0
000073 2048
000074 0020      tLe:	.db	"H  ",0
000075 7a48
000076 0020      tFe:	.db	"Hz ",0
                 
                 ; Menu values
000077 9d14
000078 af26
000079 8b0b      ptrHdr:	.db	tCap,tIndc+0x80,tFreqC,tFreqL+0x80,tHead,tHead+0x80
00007a 0115
00007b 0120
00007c 012b
00007d 012b
00007e 013b
00007f 013b      ptrFnc:	.dw	fCap,fIndc,fFrq,fFrq,fCnst,fCnst
                 
                 .equ	mEndAll	= 6		; End for all the menu's
                 .equ	mEnd	= 2		; End for normal menu's
                 
                 ;--------------------------------------------------------------------
                 ;-- Timer0 overflow interupt
                 ;-- Every 6,5536ms, Xtal=10Mhz, div=256, cnt=256
                 ;--------------------------------------------------------------------
000080 b7cf      TIMER0:	in	ssreg,SREG
                 
000081 950a      	dec	ticks			; Ticks for extra timer!
                 
000082 95da      	dec	porttim
                 ;	andi	porttim,portmax		; Only portmax value
000083 f489      	brne	ret1
                 
000084 f016      	brts	x0
000085 b41c      	  in	freqL,tcnt1l		; Save Timer1 16 bit freq value
000086 b42d      	  in	freqH,tcnt1h
                 	  ;set				; T=1, ready sample
                 ;	  sbr	ssreg,1<<SREG_T		; T=1, ready sample
                 	x0:
                 
000087 bddd      	out	TCNT1H,porttim		; Clear the freq counter
000088 bddc      	out	TCNT1L,porttim
                 
000089 2ddf      	mov	porttim,portval		; Next timer count
                 
00008a bfcf      	out	SREG,ssreg
00008b 9468      	set				; T=1, ready sample
00008c 9518      	reti
                 
                 
                 ;--------------------------------------------------------------------
                 ;-- Timer1 overflow interupt
                 ;--------------------------------------------------------------------
00008d b7cf      TIMER1:	in	ssreg,SREG
                 
00008e 20ff      	tst	portval			; Only the first time
00008f f421      	brne	err0			;  portval is zero then.
                 
000090 95d1      	neg	porttim			; portval = -porttim
                 ;	andi	porttim,portmax
000091 2efd      	mov	portval,porttim
                 
000092 e0d1      	ldi	porttim,1		; Next timer count
                 
000093 c001      	rjmp	ret1
                 
000094 6074      err0:	sbr	status,1<<sRecal	; Recalibartion needed
                 
000095 bfcf      ret1:	out	SREG,ssreg
000096 9518      	reti
                 
                 
                 ;--------------------------------------------------------------------
                 ;-- Reset / Main
                 ;--------------------------------------------------------------------
                 RESET:
000097 94f8      	cli				;Disable global interrupts
                 
                 	; Load stack pointer
000098 edbf      	ldi	tmp,low(RAMEND)
000099 bfbd      	out	SPL,tmp
                 
                 	; Port B is output (LCD)
00009a efbc      	ldi	tmp,0b11111100		; PB7..PB2 Output LCD
00009b bbb7      	out	ddrb,tmp
00009c 98c2      	cbi	prt_rs,bit_rs		; LCD RS=0
00009d 98c3      	cbi	prt_en,bit_en		; LCD EN=0
                 
00009e 988d      	IOInp	freq			; Freq counter input
00009f 9895      	IOClear	freq			; High ohm input
                 
0000a0 9a8b      	IOOut	relay_refc		; Relay output
0000a1 9a93      	IOSet	relay_refc		; Relay off (via TOR)
                 
0000a2 9a8a      	IOOut	relay_inp		; Relay output
0000a3 9a92      	IOSet	relay_inp		; Relay off (via TOR)
                 
0000a4 98b9      	IOInp	mode			; Switch mode
0000a5 9ac1      	IOSet	mode			; Source sync
                 
0000a6 98b8      	IOInp	calibr			; Switch calibrate
0000a7 9ac0      	IOSet	calibr			; Source sync
                 
                 
                 	; GIMSK: General Interrupt FLAG
0000a8 e0b0      	ldi	tmp,(0<<INT0)|(0<<INT1)
0000a9 bfbb      	out	GIMSK,tmp
                 
                 	; TIMSK: Timer/Counter Interrupt Mask
                 	; TOIE1: Timer/Counter1 Overflow Interrupt Enable
                 	; OCIE1A: Timer/Counter1 Output Compare Match Interrupt Enable
                 	; TOIE0: Timer/Counter0 Overflow Interrupt Enable
0000aa e8b2      	ldi	tmp,(1<<TOIE1)|(0<<OCIE1A)|(1<<TOIE0)
0000ab bfb9      	out	TIMSK,tmp
                 
                 	; MCUCR
                 	; SE: Sleep Enable
                 	; SM: Sleep Mode
                 	; ISC11, ISC10: Interrupt Sense Control 1 Bit 1 and Bit 0
                 	; ISC01, ISC00: Interrupt Sense Control 0 Bit 1 and Bit 0
0000ac e2b0      	ldi	tmp,(1<<SE)|(0<<SM)|(0<<ISC10)|(0<<ISC11)|(0<<ISC00)|(0<<ISC01)
0000ad bfb5      	out	MCUCR,tmp
                 
                 	; Timer0, Clock/256
                 	; Maximale tijd die we meten voor pulsen.
                 	; Bij 10MHz en prescaler van 64 is dat minimaal 610 Hz (1,6384ms)
                 .if prescale == 64
0000ae e0b3      	ldi	tmp,(0<<CS02)|(1<<CS01)|(1<<CS00)	; 64
                 .endif
                 .if prescale == 256
                 .endif
0000af bfb3      	out	TCCR0,tmp
                 
                 	; Timer1
                 	; COM1A1, COM1A0: Compare Output Mode1, Bits 1 and 0
                 	; PWM11, PWM10: Pulse Width Modulator Select Bits
0000b0 e0b0      	ldi	tmp,(0<<COM1A1)|(0<<COM1A0)|(0<<PWM11)|(0<<PWM10)
0000b1 bdbf      	out	TCCR1A,tmp
                 	;
                 	; ICNC1: Input Capture1 Noise Canceler
                 	; ICES1: Input Capture1 Edge Select
                 	; CTC1: Clear Timer/Counter1 on Compare Match
                 	; CS12, CS11, CS10: Clock Select1, Bits 2, 1 and 0 
                 	; 	111 = External Pin T1, rising edge
0000b2 e0b7      	ldi	tmp,(0<<ICNC1)|(0<<ICES1)|(0<<CTC1)|(1<<CS12)|(1<<CS11)|(1<<CS10)
0000b3 bdbe      	out	TCCR1B,tmp
                 
0000b4 9478      	sei				; Enable the interrupts
                 
                 ;	Init LCD interface
0000b5 e108      	ldi	ticks,ticks_40ms	; Min 20ms LCD
0000b6 d200      	rcall	dlong			;  Delay
0000b7 d203      	rcall	lcd_init
                 
                 	; Store the constants in SRAM
0000b8 ef8f
0000b9 ef9f
0000ba ef2f
0000bb ef3f      	loadXi	-1			; KM1 = -1
0000bc e8eb
0000bd d16d      	storeX	KM1
                 
                 	; KFRQ = Xtal / (prescaler * 256) * 100
0000be e68b
0000bf ee9e
0000c0 e020
0000c1 e030      	loadXi	xtal*100/(256*prescale)
0000c2 e9e7
0000c3 d167      	storeX	KFRQ
                 
                 	; K = 10^9 * 2^7 * prescale / (pi * Xtal) * sqrt(1000)
0000c4 eb82
0000c5 ed92
0000c6 e72d
0000c7 e030      	loadXi	1288427829875*prescale/xtal
                 ;	loadXi	8245938		; prescale=64 @10MHz
0000c8 e9e3
0000c9 d161      	storeX	KL
                 
0000ca e684
0000cb e090
0000cc e020
0000cd e030      	loadXi	100		; K100 = 100
0000ce e8ef
0000cf d15b      	storeX	K100
                 
                 	; Get the reference C from EEPROM or ROM
                 .if _UseEEProm
0000d0 d17f      	rcall	eepLd
                 ;-- V0.6 ---------------
                 ;	In case the eeprom is not initialized
0000d1 3f8f      	cpi		RX0,0xff	; if eeprom[0..1] == 0xffff
0000d2 f439      	brne	eep_ok		; then
0000d3 3f9f      	cpi		RX1,0xff
0000d4 f429      	brne	eep_ok
                 
0000d5 ea8c
0000d6 e093
0000d7 e020
0000d8 e030      	loadXi	_CRef		;   Store Cref in eeprom
0000d9 d16a      	rcall	eepSt
                 eep_ok:
                 ;-- ---- ---------------
                 .else
                 .endif
0000da e6e0
0000db d14f      	storeX	Cref
                 
                 ;--------------------------------------------------------------------
                 ;-- Start of the menu selection
                 ;--------------------------------------------------------------------
                 
0000dc 27ff      	clr	zero			; ZH Always zero for store functions
0000dd 2711      	clr	menu			; Start first menu
0000de 2777      	clr	status
                 
0000df 9bb1      	sbis	pin_mode,bit_mode	; Mode key pressed?
0000e0 6072      	sbr	status,1<<sMenuAll	;  Special menu's enabled
                 
0000e1 9bb0      	sbis	pin_calibr,bit_calibr	; Calibrate key pressed?
0000e2 d068      	rcall	changeRefC		;  Change reference C
                 
0000e3 d089      	rcall	calibrate		; Do calibrate
                 
                 MenuStart:
0000e4 eeee      	ldi	ZL,2*ptrHdr		; Get pointer to header table
0000e5 0fe1      	add	ZL,menu			; Add menu number
0000e6 95c8      	lpm				; Get ptr text and bit7
0000e7 fc07      	sbrc	r0,7
0000e8 9892      	IOClear	relay_inp		; Switch input relay On
                 
0000e9 2de0      	mov	ZL,r0
0000ea 77ef      	andi	ZL,0x7f			; Remove bit7
0000eb 0fee      	lsl	ZL			; To real cseg pointer
                 
0000ec d1e6      	rcall	lcd_clear		; LCD Clear
0000ed d1ea      	rcall	lcd_line0		; Line 0, Char 0
0000ee d1c0      	rcall	print_str
                 
0000ef 9bb1      	 sbis	pin_mode,bit_mode	; Wait release mode switch
0000f0 cffe      	rjmp	PC-1
                 
                 MenuMain:
0000f1 2fe1      	mov	ZL,menu			; Menu * 2 and remove special flags
0000f2 0fee      	lsl	ZL
0000f3 50ec      	subi	ZL,-(2*ptrFnc)		; Pointer to menu function table
0000f4 d01a      	rcall	MenuFunc		; Call the menu in Z
                 
0000f5 ef04      	ldi	ticks,ticks_400ms
0000f6 9588      wait:	sleep
                 
0000f7 9bb0      	sbis	pin_calibr,bit_calibr	; Calibrate key
0000f8 c005      	 rjmp	DoCalibrate		;  then calibrate
                 
0000f9 9bb1      	sbis	pin_mode,bit_mode	; Mode key
0000fa c007      	 rjmp	MenuNext		;  then next menu
                 
0000fb 2300      	tst	ticks
0000fc f7ca      	brpl	wait
                 
0000fd cff3      	rjmp	MenuMain
                 
                 DoCalibrate:
0000fe d06e      	rcall	calibrate		; Do calibrate
0000ff 9bb0      	 sbis	pin_calibr,bit_calibr	; Wait release calibrate switch
000100 cffe      	rjmp	PC-1
000101 cfe2      	rjmp	MenuStart
                 
                 ;-- Start tail code
                 MenuNext:
000102 eeee      	ldi	ZL,2*ptrHdr		; Get pointer to header table
000103 0fe1      	add	ZL,menu			; Add menu number
000104 95c8      	lpm				; Get ptr text and bit7
000105 fc07      	sbrc	r0,7
000106 9a92      	IOSet	relay_inp		; Switch input relay Off
                 
                 ;-- Increment the menu
000107 e0b2      	ldi	tmp,mEnd
000108 fd71      	sbrc	status,sMenuAll
000109 e0b6      	ldi	tmp,mEndAll
                 
00010a 9513      	inc	menu
00010b 171b      	cp	menu,tmp
00010c f409      	brne	PC+2
00010d 2711      	 clr	menu
00010e cfd5      	rjmp	MenuStart
                 
                 MenuFunc:				; Jump to *Z via the return stack
00010f 95c8      	lpm				; to the func pointed by Z
000110 920f      	push	r0
000111 5fef      	subi	ZL,-1			; ZL++
000112 95c8      	lpm
000113 920f      	push	r0
000114 9508      ret6:	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- Calculate the unknow Cx
                 ;--------------------------------------------------------------------
000115 d0a4      fCap:	rcall	calc1
000116 f3e8      	brcs	ret6			; OSC not running
000117 e6e4
000118 d11c      	loadX	C			; RX = C
000119 d0c9      	rcall	calc2
                 
00011a d1bf      	rcall	lcd_line1		; Line 1
00011b ece4      	ldi	ZL,2*tCx
00011c d192      	rcall	print_str
00011d eae6      	ldi	ZL,2*tCf
00011e eea2      	ldi	chr,2*tCe
00011f c153      	rjmp	print_nr
                 
                 ;--------------------------------------------------------------------
                 ;-- Calculate the unknow Lx
                 ;--------------------------------------------------------------------
000120 d099      fIndc:	rcall	calc1
000121 f390      	brcs	ret6			; OSC not running
000122 e6e8
000123 d111      	loadX	L			; RX = L
000124 d0be      	rcall	calc2
                 
000125 d1b4      	rcall	lcd_line1		; Line 1
000126 ecea      	ldi	ZL,2*tLx
000127 d187      	rcall	print_str
000128 ebe0      	ldi	ZL,2*tLf
000129 eea6      	ldi	chr,2*tLe
00012a c148      	rjmp	print_nr
                 
                 ;--------------------------------------------------------------------
                 ;-- Calculate Frequence
                 ;-- F = N * KFRQ / Portval / 100
                 ;-- KFRQ = Xtal / (prescaler * 256) * 100
                 ;--------------------------------------------------------------------
00012b d07b      fFrq:	rcall	sample			; Get a freq sample
00012c f338      	brcs	ret6			; OSC not running
00012d e9e7
00012e d10b      	loadY	KFRQ			; RY = KFRQ
00012f d0be      	rcall	mul32			; RX *= RY
000130 d10e      	rcall	ldYportval		; RY = portval
000131 d0d1      	rcall	div48			; RX /= RY
000132 e8ef
000133 d106      	loadY	K100			; RY = 100
000134 d0ce      	rcall	div48			; RX /= RY
                 
000135 d1a4      	rcall	lcd_line1		; Line 1
000136 edec      	ldi	ZL,2*tF
000137 d177      	rcall	print_str
000138 ebea      	ldi	ZL,2*tFf
000139 eeaa      	ldi	chr,2*tFe
00013a c138      	rjmp	print_nr
                 
                 ;--------------------------------------------------------------------
                 ;-- Display constants
                 ;--------------------------------------------------------------------
00013b e6e8
00013c d0f8      fCnst:	loadX	L
00013d d19a      	rcall	lcd_line0		; Line 0
00013e ede6      	ldi	ZL,2*tL
00013f d16f      	rcall	print_str
000140 ebe0      	ldi	ZL,2*tLf
000141 eea6      	ldi	chr,2*tLe
000142 d130      	rcall	print_nr
                 
000143 e6e4
000144 d0f0      	loadX	C
000145 d194      	rcall	lcd_line1		; Line 1
000146 ede0      	ldi	ZL,2*tC
000147 d167      	rcall	print_str
000148 eae6      	ldi	ZL,2*tCf
000149 eea2      	ldi	chr,2*tCe
00014a c128      	rjmp	print_nr
                 
                 
                 ;--------------------------------------------------------------------
                 ;-- Change reference C in eeprom
                 ;-- Init: boot with mode + cali key pressed
                 ;-- mode key is -1 pF, cali key is +1pF
                 ;-- Reboot for exit!
                 ;--------------------------------------------------------------------
                 changeRefC:
00014b ff71      	sbrs	status,sMenuAll		; Beide knoppen ingedrukt!
00014c 9508      	ret
                 
00014d d18a      	rcall	lcd_line0		; Print de header
00014e e9e4      	ldi	ZL,2*tCref
00014f d15f      	rcall	print_str
                 
000150 e6e0
000151 d0e3      crcprt:	loadX	Cref			; Print Cref 
000152 d187      	rcall	lcd_line1
000153 ede0      	ldi	ZL,2*tC
000154 d15a      	rcall	print_str
000155 eae6      	ldi	ZL,2*tCf
000156 eea2      	ldi	chr,2*tCe
000157 d11b      	rcall	print_nr
                 
                 	; Wacht key release
000158 9bb0      	 sbis	pin_calibr,bit_calibr	; Calibrate key
000159 cffe      	rjmp	PC-1
00015a 9bb1      	 sbis	pin_mode,bit_mode	; Mode key
00015b cffc      	rjmp	PC-3
                 
00015c e0b0      	ldi	tmp,0			; Debounce key's
00015d 95ba      	 dec	tmp
00015e f7f1      	brne	PC-1
                 
00015f e6e0
000160 d0d4      	loadX	Cref
000161 9bb0      crc1:	sbis	pin_calibr,bit_calibr	; Calibrate key
000162 c003      	rjmp	crcinc
000163 9bb1      	sbis	pin_mode,bit_mode	; Mode key
000164 c003      	rjmp	crcdec
000165 cffb      	rjmp	crc1
                 
                 .if _UseEEProm
000166 9601      crcinc:	adiw	RX0,1			; RX0:RX1 += 1
000167 c001      	rjmp	crc2
                 
000168 9701      crcdec:	sbiw	RX0,1			; RX0:RX1 -= 1
000169 e6e0
00016a d0c0      crc2:	storeX	Cref			; Cref = RX
00016b d0d8      	rcall	eepSt
                 .else
                 .endif
00016c cfe3      	rjmp	crcprt
                 
                 ;--------------------------------------------------------------------
                 ;-- Calibrate the timer
                 ;--------------------------------------------------------------------
                 calibrate:
00016d d16a      	rcall	lcd_line0		; Line 0, Char 0
00016e e1e6      	ldi	ZL,2*tHead		; "LC Meter, PE0FKO"
00016f d13f      	rcall	print_str
                 
000170 d169      	rcall	lcd_line1		; Line 1, Char 0
000171 e7e0      	ldi	ZL,2*tCali		; Print header
000172 d13c      	rcall	print_str
                 
000173 ef04      	ldi	ticks,ticks_400ms	; 400ms for stable OSC
000174 d142      	rcall	dlong
000175 94f8      	cli				; Disable interrupt
                 
                 	; Init the timer registers to default zero
000176 bdfd      	out	TCNT1H,zero		; Clear the freq counter
000177 bdfc      	out	TCNT1L,zero
000178 bff2      	out	TCNT0,zero		; Timer0 init
                 
000179 27dd      	clr	porttim			; Start counting the porttim
00017a 24ff      	clr	portval
                 
00017b e8b2      	ldi	tmp,(1<<TOV0)|(1<<TOV1)	; Reset hanging timer interrupt
00017c bfb8      	out	TIFR,tmp
                 
00017d 94e8      	clt				; T=0
00017e 9478      	sei				; Enable interrupt
00017f d027      	rcall	sample			; Wait for the counter init
                 
000180 d026      	rcall	sample			; Delay only
                 
000181 d025      	rcall	sample			; Get N1
000182 f350      	brcs	calibrate		; OSC not running
                 
000183 e6ec
000184 d0a6      	storeX	N1			; N1 = N1
000185 d064      	rcall	rxquad			; RX = N1^2
000186 e7e4
000187 d0a3      	storeX	NQ1			; NQ1 = N1^2
                 
000188 9893      	IOClear	relay_refc		; Switch Cref On
000189 d01d      	rcall	sample			; Delay only, stable osc
00018a d02f      	rcall	calc1			; Get N2 and calc
00018b 9a93      	IOSet	relay_refc		; Switch Cref Off
                 
00018c f300      	brcs	calibrate		; OSC not running?
                 
00018d 7f7b      	cbr	status,1<<sRecal	; Recalibartion done
                 
                 	;------------------------------------------------------------
                 	;-- Calculate the unknow C
                 	;-- C[32] = Cref * N2^2 / (N1^2 - N2^2)
                 	;------------------------------------------------------------
00018e e6e0
00018f d0a5      	loadX	Cref			; RX = Cref
000190 e7e8
000191 d0a8      	loadY	NQ2			; RY = N2^2
000192 d05b      	rcall	mul32			; RX = RX * RY
000193 e7ec
000194 d0a5      	loadY	ND			; RY = N1^2 - N2^2
000195 d06d      	rcall	div48			; RX = RX / RY
000196 e6e4
000197 d093      	storeX	C			; C = RX
                 
                 	;------------------------------------------------------------
                 	;-- Calculate the unknow L
                 	;-- L[32] = ( K * portval / N1 )^2 / C
                 	;-- K[32] = 10^9 * 2^7 * prescaler / (pi * Xtal) * sqrt(1000)
                 	;------------------------------------------------------------
000198 e9e3
000199 d09b      	loadX	KL			; RX = K
00019a d0a4      	rcall	ldYportval		; RY = portval
00019b d052      	rcall	mul32			; RX *= RY
00019c e6ec
00019d d09c      	loadY	N1			; RY = N1
00019e d064      	rcall	div48			; RX = RX / RY
00019f d04a      	rcall	rxquad			; RX = RX^2
0001a0 e6e4
0001a1 d098      	loadY	C			; RY = C
0001a2 d060      	rcall	div48			; RX = RX / RY
0001a3 e6e8
0001a4 d086      	storeX	L			; L = RX
                 
0001a5 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- Sample
                 ;--------------------------------------------------------------------
0001a6 9588      	sleep				; Wait for a interrupt (timer)
0001a7 f7f6      sample:	brtc	PC-1			; Is there a sample?
0001a8 2d81      	mov	RX0,freqL		; RX = freq count
0001a9 2d92      	mov	RX1,freqH
0001aa 94e8      	clt				; T=0, take next freq sample
0001ab 2e08      	mov	r0,RX0			; Test zero value
0001ac 2a09      	or	r0,RX1
0001ad f031      	breq	err1			; if not zero there is a sample!
0001ae 2722      	clr	RX2
0001af 2733      	clr	RX3
0001b0 e7e0
0001b1 d079      	storeX	N2			; N2 = sample
0001b2 9488      	clc				; No error
0001b3 9508      	ret
                 
                 err1:	; Freq count is zero then error message
0001b4 d125      	rcall	lcd_line1		; Line 1, Char 0
0001b5 e8e2      	ldi	ZL,2*tNoOSC
0001b6 d0f8      	rcall	print_str
0001b7 94e8      	clt				; Next sample now
0001b8 9408      	sec				; Error
0001b9 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- Calculate the unknow Cx
                 ;-- Cx[32] = C * (NQ1^2 - NQ2^2) / NQ2^2
                 ;--
                 ;-- Calculate the unknow Lx
                 ;-- Lx[32] = L * (NQ1^2 - NQ2^2) / NQ2^2
                 ;--------------------------------------------------------------------
0001ba dfec      calc1:	rcall	sample			; Get N2
0001bb f050      	brcs	ret5			; OSC not running
                 debug2:
0001bc d02d      	rcall	rxquad			; RX = RX^2
0001bd e7e8
0001be d06c      nxt5:	storeX	NQ2			; NQ2 = N2^2
                 
0001bf e7e4
0001c0 d079      	loadY	NQ1			; RY = N1^2
0001c1 d064      	rcall	sub32			; RY = RY - RX
0001c2 f020      	brcs	negy			; C=1, Negative
                 
0001c3 e7ec
0001c4 d06b      	storeY	ND			; ND = N1^2 - N2^2
0001c5 9488      	clc				; No error
0001c6 9508      ret5:	ret
                 
0001c7 e6ec
0001c8 d071      negy:	loadY	N1
0001c9 e7e0
0001ca d06a      	loadX	N2
0001cb d05a      	rcall	sub32			; RY = N1 - N2
                 
0001cc e8eb
0001cd d067      	loadX	KM1			; RX = -1
0001ce d057      	rcall	sub32			; RY = RY + 1
0001cf f06a      	brmi	err3			; N1=1, meer dan 2 afwijking
                 
0001d0 e6ec
0001d1 d068      	loadY	N1			; RY = N1
0001d2 d053      	rcall	sub32			; RY = RY + 1
0001d3 e6ec
0001d4 d05b      	storeY	N1			; N1 = RY
                 
0001d5 2d84      	mov	RX0,RY0			; RX = N1^2
0001d6 2d95      	mov	RX1,RY1
0001d7 2d26      	mov	RX2,RY2
0001d8 2d37      	mov	RX3,RY3
0001d9 d014      	rcall	mul32
0001da e7e4
0001db d04f      	storeX	NQ1			; NQ1 = N1^2
0001dc cfe0      	rjmp	nxt5
                 
0001dd 9408      err3:	sec				; Error
0001de 2788      	clr	RX0			; RX = 0
0001df 2799      	clr	RX1
0001e0 2722      	clr	RX2
0001e1 2733      	clr	RX3
0001e2 9508      	ret
                 
                 
0001e3 e7ec
0001e4 d055      calc2:	loadY	ND			; RY = NQ1^2 - NQ2^2
0001e5 d008      	rcall	mul32			; RX = RX * RY
0001e6 e7e8
0001e7 d052      	loadY	NQ2			; RY = NQ2^2
0001e8 d01a      	rcall	div48			; RX = RX / RY
0001e9 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- RX[64] = RX[32]^2
                 ;--------------------------------------------------------------------
0001ea 2e48      rxquad:	mov	RY0,RX0			; RX = RX^2
0001eb 2e59      	mov	RY1,RX1
0001ec 2e62      	mov	RY2,RX2
0001ed 2e73      	mov	RY3,RX3
                 
                 ;--------------------------------------------------------------------
                 ;-- RX[64] = RX[32] * RY[32]
                 ;--------------------------------------------------------------------
0001ee 24ee      mul32:	clr	RX7
0001ef 2766      	clr	RX6
0001f0 2755      	clr	RX5
0001f1 1b44      	sub	RX4,RX4		; RX4=0, C=0
0001f2 e2b1      	ldi	tmp,32+1
0001f3 f420      mnxtb:	brcc	mnoadd
0001f4 0d44      	add	RX4,RY0
0001f5 1d55      	adc	RX5,RY1
0001f6 1d66      	adc	RX6,RY2
0001f7 1ce7      	adc	RX7,RY3
0001f8 94e7      mnoadd:	ror	RX7
0001f9 9567      	ror	RX6
0001fa 9557      	ror	RX5
0001fb 9547      	ror	RX4
0001fc 9537      	ror	RX3
0001fd 9527      	ror	RX2
0001fe 9597      	ror	RX1
0001ff 9587      	ror	RX0
000200 95ba      	dec	tmp
000201 f789      	brne	mnxtb
000202 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- RX[48] = RX[48] / RY[32]
                 ;--------------------------------------------------------------------
000203 e3b1      div48:	ldi	tmp,48+1		; init loop counter
000204 2488      	clr	RR0			; clear remainder Low byte
000205 2499      	clr	RR1
000206 24aa      	clr	RR2
000207 24bb      	clr	RR3
000208 18cc      	sub	RR4,RR4			; clear remainder High byte and carry
000209 1f88      div1:	rol	RX0
00020a 1f99      	rol	RX1
00020b 1f22      	rol	RX2
00020c 1f33      	rol	RX3
00020d 1f44      	rol	RX4
00020e 1f55      	rol	RX5
00020f 95ba      	dec	tmp
000210 f409      	brne	div3
000211 9508      	ret
                 
000212 1c88      div3:	rol	RR0
000213 1c99      	rol	RR1
000214 1caa      	rol	RR2
000215 1cbb      	rol	RR3
000216 1ccc      	rol	RR4
000217 1884      	sub	RR0,RY0			;remainder = remainder - divisor
000218 0895      	sbc	RR1,RY1
000219 08a6      	sbc	RR2,RY2
00021a 08b7      	sbc	RR3,RY3
00021b 0acf      	sbc	RR4,zero
00021c f438      	brcc	div2			;if result negative
00021d 0c84      	add	RR0,RY0			;   restore remainder
00021e 1c95      	adc	RR1,RY1
00021f 1ca6      	adc	RR2,RY2
000220 1cb7      	adc	RR3,RY3
000221 1ecf      	adc	RR4,zero		; ZH is zero!
000222 9488      	clc				;   clear carry to be shifted into result
000223 cfe5      	rjmp	div1			;else
000224 9408      div2:	sec				;   set carry to be shifted into result
000225 cfe3      	rjmp	div1
                 
                 ;--------------------------------------------------------------------
                 ;-- RY[32] = RY[32] - RX[32]
                 ;--------------------------------------------------------------------
000226 1a48      sub32:	sub	RY0,RX0
000227 0a59      	sbc	RY1,RX1
000228 0a62      	sbc	RY2,RX2
000229 0a73      	sbc	RY3,RX3
00022a 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- Store and load X & Y from SRAM
                 ;--------------------------------------------------------------------
00022b 9381      stX:	st	Z+,RX0
00022c 9391      	st	Z+,RX1
00022d 9321      	st	Z+,RX2
00022e 9331      	st	Z+,RX3
00022f 9508      	ret
                 
000230 9241      stY:	st	Z+,RY0
000231 9251      	st	Z+,RY1
000232 9261      	st	Z+,RY2
000233 9271      	st	Z+,RY3
000234 9508      	ret
                 
000235 9181      ldX:	ld	RX0,Z+
000236 9191      	ld	RX1,Z+
000237 9121      	ld	RX2,Z+
000238 9131      	ld	RX3,Z+
000239 9508      	ret
                 
00023a 9041      ldY:	ld	RY0,Z+
00023b 9051      	ld	RY1,Z+
00023c 9061      	ld	RY2,Z+
00023d 9071      	ld	RY3,Z+
00023e 9508      	ret
                 
                 ldYportval:
00023f 2c4f      	mov	RY0,portval		; RY = portval
000240 2455      	clr	RY1
000241 2466      	clr	RY2
000242 2477      	clr	RY3
000243 9508      	ret
                 
                 .if _UseEEProm
                 ;--------------------------------------------------------------------
                 ;-- Eeprom Store / Load reference C
                 ;--------------------------------------------------------------------
                 eepSt:
000244 e0b0      	ldi	tmp,0
000245 bbbe      	out	EEAR,tmp
000246 bb8d      	out	EEDR,RX0
000247 d003      	rcall	eep0
000248 95b3      	inc	tmp
000249 bbbe      	out	EEAR,tmp
00024a bb9d      	out	EEDR,RX1
                 eep0:
00024b 9ae2      	sbi	EECR,EEMWE
00024c 9ae1      	sbi	EECR,EEWE
00024d 99e1      	 sbic	EECR,EEWE
00024e cffe      	rjmp	PC-1
00024f 9508      	ret
                 
                 eepLd:	; RX = EEPROM[16]
000250 e0b0      	ldi	tmp,0
000251 bbbe      	out	EEAR,tmp
000252 9ae0      	sbi	EECR,EERE
000253 b38d      	in	RX0,EEDR
000254 95b3      	inc	tmp
000255 bbbe      	out	EEAR,tmp
000256 9ae0      	sbi	EECR,EERE
000257 b39d      	in	RX1,EEDR
000258 2722      	clr	RX2
000259 2733      	clr	RX3
00025a 9508      	ret
                 .endif
                 
                 ;--------------------------------------------------------------------
                 ;-- Convert 32bits RX to decimal string
                 ;-- 10 char buffer + null
                 ;--------------------------------------------------------------------
00025b e8eb      cvt:	ldi	ZL,BUFFER+buflen
00025c e0a0      	ldi	chr,0
00025d 93a2      	st	-Z,chr		; NULL  0 EOS
                 
00025e 1baa      digit:	sub	chr,chr		; clear remainder and carry
00025f e2b1      	ldi	tmp,32+1	; init loop counter
000260 1f88      digit1:	rol	RX0
000261 1f99      	rol	RX1
000262 1f22      	rol	RX2
000263 1f33      	rol	RX3
000264 95ba      	dec	tmp		; decrement counter
000265 f041      	breq	digit3		; if done then return
000266 1faa      	rol	chr		; shift dividend into remainder
000267 50aa      	subi	chr,10		; remainder = remainder - divisor
000268 f418      	brcc	digit2		;if result negative
000269 5fa6      	subi	chr,-10		;   restore remainder
00026a 9488      	clc			;   clear carry to be shifted into result
00026b cff4      	rjmp	digit1		;else
00026c 9408      digit2:	sec			;   set carry to be shifted into result
00026d cff2      	rjmp	digit1
00026e 5da0      digit3:	subi	chr,-'0'
                 
00026f 93a2      	st	-Z,chr
000270 38e0      	cpi	ZL,BUFFER
000271 f761      	brne	digit
                 
000272 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- Print RX and text on line 0 or 1
                 ;-- ZL = rom text
                 ;-- chr type ('F','H')
                 ;--------------------------------------------------------------------
                 print_nr:
000273 93af      	push	chr
000274 93ef      	push	ZL
                 
000275 dfe5      	rcall	cvt
                 
000276 e8e0      	ldi	ZL,BUFFER
000277 91a1      nxt2:	ld	chr,Z+			; Skip leading '0'
000278 33a0      	cpi	chr,'0'
000279 f3e9      	breq	nxt2
                 
00027a 30a0      	cpi	chr,0			; EOS?
00027b f409      	brne	PC+2
00027c 95ea      	 dec	ZL			; Reset pointer to last char+1
                 
00027d 93ef      	push	ZL			; Save string start+1
                 
00027e 5fec      	subi	ZL,-(5-1)		; New end of string
00027f 38eb      	cpi	ZL,BUFFER+buflen	; Check for array size
000280 f00a      	brmi	PC+2
000281 e8ea      	 ldi	ZL,BUFFER+buflen-1	; Litmit to array size
                 
000282 27aa      	clr	chr			; Set end of string
000283 83a0      	st	Z,chr
000284 50e5      	subi	ZL,5			; ZL is begin of string
                 
000285 91a1      l8:	ld	chr,Z+			; Output space for leading '0'
000286 33a0      	cpi	chr,'0'
000287 f419      	brne	l11
000288 e2a0      	ldi	chr,' '
000289 d053      	rcall	putch
00028a cffa      	rjmp	l8
                 
00028b 38e8      l11:	cpi	ZL,BUFFER+buflen-3	; < 1000 extra space for missing comma
00028c f042      	brmi	l12
00028d 93af      	 push	chr
00028e 30a0      	 cpi	chr,0
00028f f011      	 breq	PC+3
000290 e2a0      	  ldi	chr,' '
000291 c001      	 rjmp	PC+2
000292 e3a0      	  ldi	chr,'0'
000293 d049      	 rcall	putch
000294 91af      	 pop	chr
                 
000295 30a0      l12:	cpi	chr,0			; Output digits left comma
000296 f071      	breq	ends
000297 d045      	rcall	putch
000298 91a1      	ld	chr,Z+
000299 38e2      	cpi	ZL,BUFFER+buflen-(3*3)
00029a f021      	breq	l14
00029b 38e5      	cpi	ZL,BUFFER+buflen-(2*3)
00029c f011      	breq	l14
00029d 38e8      	cpi	ZL,BUFFER+buflen-(1*3)
00029e f7b1      	brne	l12
                 
00029f 95ea      l14:	dec	ZL			; Output comma
0002a0 e2ac      	ldi	chr,','
                 
0002a1 d03b      L15:	rcall	putch			; Output digits rigth comma
0002a2 91a1      	ld	chr,Z+
0002a3 30a0      	cpi	chr,0
0002a4 f7e1      	brne	L15
                 
0002a5 e2a0      ends:	ldi	chr,' '
0002a6 d036      	rcall	putch
                 
0002a7 91ef      	pop	ZL			; 
0002a8 58e1      	subi	ZL,BUFFER+1
0002a9 91bf      	pop	tmp
0002aa 0feb      	add	ZL,tmp
                 
0002ab 95c8      	lpm
0002ac 2da0      	mov	chr,r0
0002ad d02f      	rcall	putch
                 
0002ae 91ef      	pop	ZL
                 
                 print_str:
0002af 95c8      	lpm
0002b0 9631      	adiw	ZL,1
0002b1 2000      	tst	r0
0002b2 f019      	breq	ret3
0002b3 2da0      	mov	chr,r0
0002b4 d028      	rcall	putch
0002b5 cff9      	rjmp	print_str
0002b6 9508      ret3:	ret
                 
                 ; N = uS * xtal / (prescale * 256) / 10e6 
                 dlong:	; Delay long in steps of ticks
0002b7 9588      	sleep
0002b8 2300      	tst	ticks
0002b9 f7e9      	brne	dlong
0002ba 9508      	ret
                 
                 ;--------------------------------------------------------------------
                 ;-- LCD Functions
                 ;--------------------------------------------------------------------
                 
                 lcd_init:
0002bb 98c2      	cbi	prt_rs,bit_rs
                 
0002bc e3a0      	ldi	chr,$30			;
0002bd d023      	rcall	wr_lcd8			;1) Function Set (8-Bit Interface)
                 
0002be eca8      	ldi	chr,200			;5mS Delay
0002bf d035      	rcall	dX25uS
                 
0002c0 e3a0      	ldi	chr,$30			;
0002c1 d01f      	rcall	wr_lcd8			;2) Function Set (8-Bit Interface)
                 
0002c2 e3a0      	ldi	chr,$30			;
0002c3 d01d      	rcall	wr_lcd8			;3) Function Set (8-Bit Interface)
                 
0002c4 e2a0      	ldi	chr,$20			;
0002c5 d01b      	rcall	wr_lcd8			;4) Function Set (4-Bit Interface)
                 
                 	; 4 Bit mode active!
                 
0002c6 e2a8      	ldi	chr,0b00101000		;$28 [0 0 1 DL.N F x x]
0002c7 d02a      	rcall	wr_ins			;5) Interface data length 4 bits (DL), 2 line (N), Font 5*8 (F)
                 
0002c8 e0a8      	ldi	chr,0b00001000		;$08 [0 0 0 0 1 D C B]
0002c9 d028      	rcall	wr_ins			;6) Display, Cursor, Blinking OFF
                 
0002ca e0a1      	ldi	chr,0b00000001		;$01 [0 0 0 0.0 0 0 1]
0002cb d026      	rcall	wr_ins			;6) Display clear
                 
0002cc e5a0      	ldi	chr,2000/25		;2mS delay
0002cd d027      	rcall	dX25uS
                 
0002ce e0a6      	ldi	chr,0b00000110		;$06 [0 0 0 0 0 1 I/D SH]
0002cf d022      	rcall	wr_ins			;6) Entry mode
                 
0002d0 e0ac      	ldi	chr,0b00001100		;$0C [0 0 0 0.1 D C B]
0002d1 d020      	rcall	wr_ins			;7) Display ON, cursor OFF, blink OFF
                 
0002d2 9508      	ret
                 
                 lcd_clear:
0002d3 e0a1      	ldi	chr,$01			;clear display
0002d4 d01d      	rcall	wr_ins
0002d5 e5a0      	ldi	chr,2000/25		;2mS (Spec 1,64mS)
0002d6 d01e      	rcall	dX25uS
0002d7 9508      	ret
                 
                 lcd_line0:
0002d8 e8a0      	ldi	chr,$80+0x00		; Line 0
0002d9 c018      	rjmp	wr_ins
                 
                 lcd_line1:
0002da eca0      	ldi	chr,$80+0x40		; Line 1
0002db c016      	rjmp	wr_ins
                 
                 ; space()
                 ; register: chr, tmp
0002dc e2a0      space:	ldi	chr,' '
                 
                 ; putch( chr=Char )
                 ; register: chr, tmp
0002dd 9ac2      putch:	sbi	prt_rs,bit_rs
0002de d005      	rcall	wr_lcd
0002df e0a2      	ldi	chr,50/25		; 50uS
0002e0 c014      	rjmp	dX25uS			; Delay 32uS
                 
0002e1 d006      wr_lcd8:rcall	wr_lcd_1		; Write code in 8 bits mode
0002e2 e0a8      	ldi	chr,200/25		; 200uS
0002e3 c011      	rjmp	dX25uS			; Delay 32uS
                 
                 ; wr_lcd( chr=Code )
                 ; local: tmp
0002e4 93af      wr_lcd:	push	chr
0002e5 d002      	rcall	wr_lcd_1
0002e6 91af      	pop	chr
0002e7 95a2      	swap	chr
                 wr_lcd_1:
0002e8 93bf      	push	tmp
0002e9 9ac3      	sbi	prt_en,bit_en		; Enable strobe up
0002ea 7fa0      	andi	chr,0xF0
0002eb b3b8      	in	tmp,prt_lcd
0002ec 70bf      	andi	tmp,0x0F
0002ed 2bab      	or	chr,tmp
0002ee bba8      	out	prt_lcd,chr
0002ef 98c3      	cbi	prt_en,bit_en		; Enable strobe down
0002f0 91bf      	pop	tmp
0002f1 9508      	ret
                 
0002f2 98c2      wr_ins:	cbi	prt_rs,bit_rs
0002f3 dff0      	rcall	wr_lcd
0002f4 e0a4      	ldi	chr,100/25		; 100uS
                 
                 ;Xm Sec delay, X=chr
0002f5 93bf      dX25uS:	push	tmp
0002f6 e1b9      	ldi	tmp,25*xtal/10000000	; 25us (10 cycles)
0002f7 d005      	rcall	duS			;+7
0002f8 95ba      	dec	tmp			;+1
0002f9 f7e9      	brne	pc-2			;+2
0002fa 95aa      	dec	chr
0002fb f7d1      	brne	pc-5
0002fc 91bf      	pop	tmp
                 duS:					; Delay small 7 cylces, at 8Mhz clock
                 					;+3 cycles being "rcall"ed
                 					;+4 cycles to return. 10 cycles total
0002fd 9508      	ret
                 
                 ; EOF


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

AT90S2313 register use summary:
r0 :  10 r1 :   2 r2 :   2 r3 :   0 r4 :   9 r5 :   9 r6 :   9 r7 :   9 
r8 :   4 r9 :   4 r10:   4 r11:   4 r12:   5 r13:   0 r14:   3 r15:   5 
r16:   6 r17:   7 r18:  16 r19:  16 r20:   5 r21:   4 r22:   3 r23:   6 
r24:  21 r25:  19 r26:  63 r27:  48 r28:   4 r29:   8 r30:  83 r31:   6 
x  :   0 y  :   0 z  :  23 
Registers used: 31 out of 35 (88.6%)

AT90S2313 instruction use summary:
.lds  :   0 .sts  :   0 adc   :   7 add   :   5 adiw  :   2 and   :   0 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   7 breq  :   8 brge  :   0 brhc  :   0 brhs  :   0 
brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   3 brne  :  16 
brpl  :   1 brsh  :   0 brtc  :   1 brts  :   1 brvc  :   0 brvs  :   0 
bset  :   0 bst   :   0 cbi   :  11 cbr   :   1 clc   :   4 clh   :   0 
cli   :   2 cln   :   0 clr   :  25 cls   :   0 clt   :   3 clv   :   0 
clz   :   0 com   :   0 cp    :   1 cpc   :   0 cpi   :  14 cpse  :   0 
dec   :  10 eor   :   0 icall :   0 ijmp  :   0 in    :   7 inc   :   3 
ld    :  12 ldd   :   0 ldi   : 130 lds   :   0 lpm   :  18 lsl   :   2 
lsr   :   0 mov   :  18 neg   :   1 nop   :   0 or    :   2 ori   :   0 
out   :  23 pop   :   7 push  :   9 rcall : 129 ret   :  25 reti  :  10 
rjmp  :  35 rol   :  16 ror   :   8 sbc   :   7 sbci  :   0 sbi   :  14 
sbic  :   1 sbis  :  10 sbiw  :   1 sbr   :   2 sbrc  :   3 sbrs  :   1 
sec   :   4 seh   :   0 sei   :   2 sen   :   0 ser   :   0 ses   :   0 
set   :   1 sev   :   0 sez   :   0 sleep :   3 st    :  11 std   :   0 
sts   :   0 sub   :   5 subi  :   8 swap  :   1 tst   :   4 wdr   :   0 

Instructions used: 56 out of 102 (54.9%)

AT90S2313 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0005fc   1298    234   1532    2048  74.8%
[.dseg] 0x000060 0x00009b      0     59     59     128  46.1%
[.eseg] 0x000000 0x000002      0      2      2     128   1.6%

Assembly complete, 0 errors, 0 warnings
